# -*- coding: utf-8 -*-
"""Sender/Reciever_v1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/155Nh5U6NJNZ_NLxVmwe_1Tt6YEaR8tgo
"""

#Imports
import math
import random
from sympy import isprime

# Key_generator/Encryption/Decryption functions
# msg: message [part]
# p, q: prime numbers, p --- shared key
# m = p*q
# r: random number
# y: ciphertext
# key: same thing as p but from perspective of recieveing end

# This is an implementation of Gortiâ€™s Enhanced Homomorphic Cryptosystem (EHC)

def key_generator():
  # Generating q and m --- again the range in which they fall is completely arbitrary
  primes = [k for k in range(1, 1000000) if isprime(k)]
  p = random.choice(primes)
  q = random.choice(primes)
  r = random.randint(1, 1000000)

  return p, q, r

def encrypt(msg, key, q, r):
  # The range in which r can fall is arbitrary so changing it is not an issue
   
  m = key*q



  # Generating Ciphertext
  C = (msg + r * (key**q)) % m

  # Returning ciphertext 
  return C



def decrypt(y, key):
  x = y % key
  return x

# Sender Code v1 ----- Does everything UP UNTIL ACTUALLY SENDING
# M: Message
# n: Number of disjointed paths
# r: Number of required disjoint active paths in each group
# G: Number of of groups of disjoint paths

def Sender_Function(M, n, r):
  G = int(math.floor(n/r)) 
  msg_parts_arr = []
  id_sum = 0
  key, q, real_r = key_generator()


  for x in range(G):
     group_id = x + 1
     msg_parts_arr.append([group_id, encrypt(int(M/G), key, q, real_r)])
     id_sum += group_id

  # At the end of this, msg_parts_arr is every group of message parts for sending

  # The return statement is really just a substitute for actual sending
  return msg_parts_arr, id_sum, key

#Reciever Code v1 ----- Does everything AFTER ACTUAL RECEPTION AND COMPILATION OF PACKETS

def Reciever_Function(id_sum, in_arr, key):
  id_found_arr = []
  sum = 0
  counter = 0
  E_M = 0
  while(sum != id_sum):
    current_id = in_arr[counter][0]
    item = in_arr[counter][1]

    # Want to drop it in this case
    if(current_id in id_found_arr):
      in_arr.pop(counter)
      # Add in whatever is needed to completely drop that packet

    else: 
      id_found_arr.append(current_id)
      sum += current_id
      E_M += item
      counter += 1
  M = int(decrypt(E_M, key))
  return M

# Testing the above code
arr, sum, key = Sender_Function(9, 12, 4)
print(Reciever_Function(sum, arr, key))